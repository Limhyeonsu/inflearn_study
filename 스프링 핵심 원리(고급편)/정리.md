# AOP

## 템플릿 메서드 패턴
`상속`을 통한 방법

템플릿은 기준이 되는 거대한 틀, 변하지 않는 부분(부가기능)은 템플릿에 몰아두고, 변하는 부분(핵심기능)은 별도로 호출해서 해결

부모 클래스(추상클래스)에 부가기능 로직을 담은 메서드를 생성 후, 핵심기능은 자식클래스에서 오버라이딩하여 로직을 담도록한다. 부가기능 로직안에서 핵심기능 메서드는 호출만 하면 된다.

단, 자식 클래스를 계속 만들어야 하는 단점이 존재한다. 부모 클래스의 기능을 전혀 사용하지 않음에도 부모 클래스를 강하게 결합(의존)하고 있다.

## 전략 패턴
`인터페이스` 위임을 통한 방법

변하지 않는 부분(부가기능)은 Context 라는 클래스에 두고, 변하는 부분(핵심기능)은 Strategy 라는 인터페이스를 만들고 해당 인터페이스를 구현하도록해서 상속의 단점을 보완한 위임으로 문제를 해결한다.

전략패턴의 핵심은 Context는 Strategy 인터페이스에만 의존한다는 것이다. Strategy 구현체를 변경하거나 새로 만들어도 Context 코드에는 영향을 주지 않는다.

Context와 Strategy를 실행전에 원하는 모양으로 조립 후 이후 Context를 실행하기 때문에 조립 이후 전략을 변경하기가 번거롭다. -> `생성자를 통해 Context에 Strategy를 주입하는 방식`

위 문제를 개선하기 위해서는 Context를 실행할 때 Strategy를 파라미터로 받는 것이다. 그러면 전략을 유연하게 변경 가능하다. 단, 실행시 전략을 지정해야한다.

## 템플릿 콜백 패턴
전략패턴에서 Context 실행시 Strategy를 파라미터로 받는 방식이다.

스프링에서 XXXTemplate 이름은 템플릿 콜백 패턴으로 만들어져 있다. 콜백이란 코드가 호출은 되는데 코드를 넘겨준 곳의 뒤에서 실행된다는 뜻이다. 콜백을 사용하는 경우 익명내부클래스나 람다를 사용하는 것이 편리하다.

## 프록시 패턴, 데코레이터 패턴
* 프록시 - 클라이언트가 요청한 결과를 서버에 직접 요청하는 것이 아닌 `대리자`를 통해 간접적으로 서버에 요청할 수 있따. 이러한 대리자를 프록시라 한다.

객체가 프록시가 되려면 클라이언트는 서버에게 요청한 것인지 프록시에게 요청한 것인지 몰라야한다. __(즉 서버와 프록시는 같은 인터페이스를 사용)__ 클라이언트는 서버 인터페이스에만 의존하고, DI를 통해 서버, 프록시를 대체할 수 있다.

[프록시의 주요기능]
* 접근제어 : 권한에 따른 접근 차단, 캐싱, 지연로딩 => `프록시 패턴`
* 부가기능추가 : `데코레이터 패턴`

데코레이터 패턴에서 데코레이터들은 항상 __꾸며줄 대상__ 이 필요하다. 따라서 내부에서 호출 대상을 가지고 있어야 한다. 그리고 이 대상을 호출해야 하는데 이 부분이 __중복__ 된 코드로 나타난다. 그래서 중복 제거를 위해 추상클래스를 만드는 방법이 있다.

*인터페이스가 없는 구체 클래스에 프록시를 적용할 때 구체 클래스를 상속받아서 해당 메서드를 오버라이딩하여 부가기능을 추가한다.

## 리플렉션
클래스, 메서드의 __메타정보__ 를 동적으로 획득하고, 코드도 동적으로 호출할 수 있다. 리플렉션을 사용해서 Class, Method 타입으로 추상화 가능 단, 리플렉션 기술은 런타임에 동작하기 때문에 컴파일 시점에 오류를 발견할 수 없다.

## 동적 프록시
JDK 동적 프록시 적용할 로직은 InvocationHandler 인터페이스 구현, `인터페이스가 있는 경우`에만 사용할 수 있다. 구체 클래스만 있는 경우에는 CGLIB를 사용하여 동적프록시를 적용한다.(MethodInterceptor 인터페이스 구현)

enhancer.setSuperClass(class지정)을 통해 구체 클래스를 상속받아서 프록시를 생성한다.

## 스프링이 지원하는 프록시(프록시 팩토리)
프록시 팩토리는 동적 프록시를 통합해서 편리하게 사용가능한 기능이다. 인터페이스가 있으면 JDK 동적 프록시를 사용하고, 구체 클래스만 있다면 CGLIB를 사용한다. 부가기능 적용시 Advice라는 것을 사용

또한 특정 메서드만 부가기능을 적용하고 싶을 때 Pointcut을 사용한다. Advice를 생성시 MethodInterceptor를 구현해야함(CGLIB에서 사용하는 인터페이스와 패키지가 다름!) 구현시 target 정보는 필요없다. 파라미터에 있는 MethodInvocation에 타켓 정보가 있기 때문이다.

인터페이스가 있어도 강제로 CGLIB를 사용하고 싶은 경우에는 proxyFactory.setProxyTargetClass(true); 지정한다.

* 포인트컷 : 부가기능을 적용할지 말지 필터링
* 어드바이스 : 프록시가 호출하는 부가기능
* 어드바이저 : 포인트컷1 + 어드바이스1

## 빈 후처리기
BeanPostProcessor 인터페이스 구현, 프록시 적용시 필요한 패키지에만 적용하도록 한다.(더 좋은 방법은 Pointcut을 이용해서 거른다.)

스프링이 제공하는 빈 후처리기 >> aop 라이브러리 의존성 추가하면 자동으로 `자동 프록시 생성기`라는 빈 후처리기에서 스프링빈에 자동으로 등록한다. 스프링 컨테이너에서 Advisor를 조회, 포인트컷(프록시 적용여부 판단, 어드바이스 적용여부 판단)을 통해 프록시 대상인지 확인한다.

자동 프록시 생성기는 @Aspect 애너테이션이 사용된 곳에서 어드바이저를 조회해서 사용한다.

단순 메서드 명으로 필터링하게되면 의도하지 않은 스프링빈도 프록시가 적용될 수 있기때문에 클래스도 지정하여 세밀하게 필터링하는 것이 필요하다. (AspectJ 포인트컷 표현식 사용)

AopUtils.isAopProxy(...) 프록시 적용여부 확인

## AOP

## 스프링 AOP 주의사항