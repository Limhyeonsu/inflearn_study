# AOP

## 템플릿 메서드 패턴
`상속`을 통한 방법

템플릿은 기준이 되는 거대한 틀, 변하지 않는 부분(부가기능)은 템플릿에 몰아두고, 변하는 부분(핵심기능)은 별도로 호출해서 해결

부모 클래스(추상클래스)에 부가기능 로직을 담은 메서드를 생성 후, 핵심기능은 자식클래스에서 오버라이딩하여 로직을 담도록한다. 부가기능 로직안에서 핵심기능 메서드는 호출만 하면 된다.

단, 자식 클래스를 계속 만들어야 하는 단점이 존재한다. 부모 클래스의 기능을 전혀 사용하지 않음에도 부모 클래스를 강하게 결합(의존)하고 있다.

## 전략 패턴
`인터페이스` 위임을 통한 방법

변하지 않는 부분(부가기능)은 Context 라는 클래스에 두고, 변하는 부분(핵심기능)은 Strategy 라는 인터페이스를 만들고 해당 인터페이스를 구현하도록해서 상속의 단점을 보완한 위임으로 문제를 해결한다.

전략패턴의 핵심은 Context는 Strategy 인터페이스에만 의존한다는 것이다. Strategy 구현체를 변경하거나 새로 만들어도 Context 코드에는 영향을 주지 않는다.

Context와 Strategy를 실행전에 원하는 모양으로 조립 후 이후 Context를 실행하기 때문에 조립 이후 전략을 변경하기가 번거롭다. -> `생성자를 통해 Context에 Strategy를 주입하는 방식`

위 문제를 개선하기 위해서는 Context를 실행할 때 Strategy를 파라미터로 받는 것이다. 그러면 전략을 유연하게 변경 가능하다. 단, 실행시 전략을 지정해야한다.

## 템플릿 콜백 패턴
전략패턴에서 Context 실행시 Strategy를 파라미터로 받는 방식이다.

스프링에서 XXXTemplate 이름은 템플릿 콜백 패턴으로 만들어져 있다. 콜백이란 코드가 호출은 되는데 코드를 넘겨준 곳의 뒤에서 실행된다는 뜻이다. 콜백을 사용하는 경우 익명내부클래스나 람다를 사용하는 것이 편리하다.

## 프록시 패턴, 데코레이터 패턴
* 프록시 - 클라이언트가 요청한 결과를 서버에 직접 요청하는 것이 아닌 `대리자`를 통해 간접적으로 서버에 요청할 수 있따. 이러한 대리자를 프록시라 한다.

객체가 프록시가 되려면 클라이언트는 서버에게 요청한 것인지 프록시에게 요청한 것인지 몰라야한다. __(즉 서버와 프록시는 같은 인터페이스를 사용)__ 클라이언트는 서버 인터페이스에만 의존하고, DI를 통해 서버, 프록시를 대체할 수 있다.

[프록시의 주요기능]
* 접근제어 : 권한에 따른 접근 차단, 캐싱, 지연로딩 => `프록시 패턴`
* 부가기능추가 : `데코레이터 패턴`

데코레이터 패턴에서 데코레이터들은 항상 __꾸며줄 대상__ 이 필요하다. 따라서 내부에서 호출 대상을 가지고 있어야 한다. 그리고 이 대상을 호출해야 하는데 이 부분이 __중복__ 된 코드로 나타난다. 그래서 중복 제거를 위해 추상클래스를 만드는 방법이 있다.

*인터페이스가 없는 구체 클래스에 프록시를 적용할 때 구체 클래스를 상속받아서 해당 메서드를 오버라이딩하여 부가기능을 추가한다.

## 리플렉션
클래스, 메서드의 __메타정보__ 를 동적으로 획득하고, 코드도 동적으로 호출할 수 있다. 리플렉션을 사용해서 Class, Method 타입으로 추상화 가능 단, 리플렉션 기술은 런타임에 동작하기 때문에 컴파일 시점에 오류를 발견할 수 없다.

## 동적 프록시
JDK 동적 프록시 적용할 로직은 InvocationHandler 인터페이스 구현, `인터페이스가 있는 경우`에만 사용할 수 있다. 구체 클래스만 있는 경우에는 CGLIB를 사용하여 동적프록시를 적용한다.(MethodInterceptor 인터페이스 구현)

enhancer.setSuperClass(class지정)을 통해 구체 클래스를 상속받아서 프록시를 생성한다.

## 스프링이 지원하는 프록시(프록시 팩토리)
프록시 팩토리는 동적 프록시를 통합해서 편리하게 사용가능한 기능이다. 인터페이스가 있으면 JDK 동적 프록시를 사용하고, 구체 클래스만 있다면 CGLIB를 사용한다. 부가기능 적용시 Advice라는 것을 사용

또한 특정 메서드만 부가기능을 적용하고 싶을 때 Pointcut을 사용한다. Advice를 생성시 MethodInterceptor를 구현해야함(CGLIB에서 사용하는 인터페이스와 패키지가 다름!) 구현시 target 정보는 필요없다. 파라미터에 있는 MethodInvocation에 타켓 정보가 있기 때문이다.

인터페이스가 있어도 강제로 CGLIB를 사용하고 싶은 경우에는 proxyFactory.setProxyTargetClass(true); 지정한다.

* 포인트컷 : 부가기능을 적용할지 말지 필터링
* 어드바이스 : 프록시가 호출하는 부가기능
* 어드바이저 : 포인트컷1 + 어드바이스1

## 빈 후처리기
BeanPostProcessor 인터페이스 구현, 프록시 적용시 필요한 패키지에만 적용하도록 한다.(더 좋은 방법은 Pointcut을 이용해서 거른다.)

스프링이 제공하는 빈 후처리기 >> aop 라이브러리 의존성 추가하면 자동으로 `자동 프록시 생성기`라는 빈 후처리기에서 스프링빈에 자동으로 등록한다. 스프링 컨테이너에서 Advisor를 조회, 포인트컷(프록시 적용여부 판단, 어드바이스 적용여부 판단)을 통해 프록시 대상인지 확인한다.

자동 프록시 생성기는 @Aspect 애너테이션이 사용된 곳에서 어드바이저를 조회해서 사용한다.

단순 메서드 명으로 필터링하게되면 의도하지 않은 스프링빈도 프록시가 적용될 수 있기때문에 클래스도 지정하여 세밀하게 필터링하는 것이 필요하다. (AspectJ 포인트컷 표현식 사용)

AopUtils.isAopProxy(...) 프록시 적용여부 확인

## AOP
AOP는 Aspect를 사용한 관점지향 프로그래밍

Aspect : 부가기능 + 부가기능을 어디에 적용할지

횡단관심사 => 하나의 부가기능이 여러곳에 동일하게 사용된다는 뜻

[AOP 적용방식]
* 컴파일 시점 : 클래스 파일을 만드는 시점에 부가기능 로직 추가, AspectJ가 제공하는 컴파일러가 필요함 (위빙-원본 로직에 부가기능 로직이 추가됨)
* 클래스 로딩 시점 : 클래스 파일에 JVM에 저장되기 전 부가기능 로직 추가, Java Instrumentation (로드타임 위빙)
* 런타임 시점 : 이미 자바가 실행된 후 프록시를 사용하여 부가기능 추가(프록시 사용)

컴파일 시점, 클래스 로딩 시점은 AspectJ를 사용하고, 복잡하다. 대신 소스코드에서 다양한 위치에 부가기능을 추가할 수 있다. `프록시를 사용하는 방식(스프링 AOP)은 메서드 실행 지점에만 부가기능을 적용`할 수 있다. 그리고 스프링빈에만 AOP 적용 가능

[용어]
* 조인포인트 : 어드바이스가 적용될 수 있는 위치(스프링 AOP는 메서드 실행시점)
* 포인트컷 : 조인포인트 중 어드바이스가 적용될 위치 선별(스프링 AOP는 메서드 실행시점)
* 타켓 : 어드바이스를 받는 객체
* 어드바이스 : 부가기능, Around(주변), Before(전), After(후)
* Aspect : 어드바이스 + 포인트컷 모듈화
* 어드바이저 : 1개의 어드바이스 + 1개의 포인트컷
* AOP 프록시 : JDK 동적 프록시, CGLIB

```
//ex)
@Pointcut(포인트컷 표현식)
private void allOrder(){ }
- 반환 타입은 void, 코드내용은 비워져야 함, allOrder은 포인트컷 시그니처


@Around("allOrder()")
포인트컷 시그니처를 사용하면 의미를 부여할 수 있다. 또 여러 어드바이스에서 사용가능하다. 포인트컷은 &&, ||, ! 으로 조합할 수 있다.
```
포인트컷은 외부클래스에 따로 모아둘 수 있다. Around 설정시 패키지명을 포함한 포인트컷 시그니처를 입력하면 된다.

어드바이스는 기본적으로 순서를 보장하지 않는다. 순서를 보장하고 싶으면 @Aspect 적용단위로 @Order(클래스 단위로 지정가능, 내부 클래스로 만들면 된다.) 애너테이션을 적용해야한다. __하나의 에스팩트에 여러 어드바이스는 순서를 보장하지 않는다__

[어드바이스 종류]
* @Around : 메서드 호출 전후 수행, 조인포인트 실행여부 선택, 반환값 변환, 예외변환등 가능
* @Before : 조인포인트 실행 이전에 실행
* @AfterReturning : 조인포인트가 정상완료후 실행
* @AfterThrowing : 메서드가 예외를 던지는 경우 실행
* @After : 조인포인트가 정상, 예외에 상관없이 실행

@Around는 ProceedingJoinPoint를 사용해야 한다. (타깃호출 때문에) 항상 타켓호출을 해야한다.

동일한 에스펙트 안에서 조인 포인트의 우선순위가 스프링 5.2.7부터 지정됨, Around -> Before -> After -> AfterReturning -> afterThrowing

## 스프링 AOP 주의사항
스프링은 프록시 방식의 AOP를 사용. 그래서 AOP를 적용하려면 프록시를 통해서 대상 객체를 호출해야함 대상 객체를 직접 호출하면 AOP 적용X

__대상 객체 내부에서 메서드 호출이 발생하면 프록시를 거치지 않고, 대상 객체를 직접 호출한다.(즉 AOP 적용 X)__

[대안]
1. 자기자신 주입 : ex) Service 안에 자기자신을 주입받을 수 있게 필드 선언하고, 내부 메서드 호출시 this.method() => X, service.method()로 호출하기(외부호출식으로, 단 생성자 주입방식을 사용하면 순환참조 문제가 발생됨) 
2. 지연조회 : 스프링 빈을 생성시점이 아닌 실제 객체 사용시점에 컨테이너에서 조회하도록 지연시킨다.(ObjectProvider 사용)
3. 구조변경 : 내부호출이 발생하지 않도록 구조변경 예) 클래스 분리

[프록시 기술과 한계]
1. 타입 캐스팅 : JDK 동적 프록시는 프록시 타겟을 구체클래스로 지정해도 인터페이스가 있따면 인터페이스 기반으로 프록시를 생성함. 따라서 구체클래스로 캐스팅이 불가하다.
2. 의존관계 주입 : 구체클래스를 필드에 선언하여 의존관계 주입을 받는 경우 JDK 동적 프록시 생성시 인터페이스를 빈으로 등록했으므로 오류 발생
3. CGLIB : 대상 클래스에 기본 생성자가 필수, 생성자 2번호출, final 키워드 클래스, 메서드 사용불가

__스프링 4.0부터 Objenesis 라이브러리 사용으로 'final' 제외한 단점 해결 스프링부트 2.0부터 CGLIB를 기본으로 사용해서 JDK 동적 프록시 문제점 해결__