# AOP

## 템플릿 메서드 패턴
`상속`을 통한 방법

템플릿은 기준이 되는 거대한 틀, 변하지 않는 부분(부가기능)은 템플릿에 몰아두고, 변하는 부분(핵심기능)은 별도로 호출해서 해결

부모 클래스(추상클래스)에 부가기능 로직을 담은 메서드를 생성 후, 핵심기능은 자식클래스에서 오버라이딩하여 로직을 담도록한다. 부가기능 로직안에서 핵심기능 메서드는 호출만 하면 된다.

단, 자식 클래스를 계속 만들어야 하는 단점이 존재한다. 부모 클래스의 기능을 전혀 사용하지 않음에도 부모 클래스를 강하게 결합(의존)하고 있다.

## 전략 패턴
`인터페이스` 위임을 통한 방법

변하지 않는 부분(부가기능)은 Context 라는 클래스에 두고, 변하는 부분(핵심기능)은 Strategy 라는 인터페이스를 만들고 해당 인터페이스를 구현하도록해서 상속의 단점을 보완한 위임으로 문제를 해결한다.

전략패턴의 핵심은 Context는 Strategy 인터페이스에만 의존한다는 것이다. Strategy 구현체를 변경하거나 새로 만들어도 Context 코드에는 영향을 주지 않는다.

Context와 Strategy를 실행전에 원하는 모양으로 조립 후 이후 Context를 실행하기 때문에 조립 이후 전략을 변경하기가 번거롭다. -> `생성자를 통해 Context에 Strategy를 주입하는 방식`

위 문제를 개선하기 위해서는 Context를 실행할 때 Strategy를 파라미터로 받는 것이다. 그러면 전략을 유연하게 변경 가능하다. 단, 실행시 전략을 지정해야한다.

## 템플릿 콜백 패턴
전략패턴에서 Context 실행시 Strategy를 파라미터로 받는 방식이다.

스프링에서 XXXTemplate 이름은 템플릿 콜백 패턴으로 만들어져 있다. 콜백이란 코드가 호출은 되는데 코드를 넘겨준 곳의 뒤에서 실행된다는 뜻이다. 콜백을 사용하는 경우 익명내부클래스나 람다를 사용하는 것이 편리하다.

## 프록시 패턴, 데코레이터 패턴
* 프록시 - 클라이언트가 요청한 결과를 서버에 직접 요청하는 것이 아닌 `대리자`를 통해 간접적으로 서버에 요청할 수 있따. 이러한 대리자를 프록시라 한다.

객체가 프록시가 되려면 클라이언트는 서버에게 요청한 것인지 프록시에게 요청한 것인지 몰라야한다. __(즉 서버와 프록시는 같은 인터페이스를 사용)__ 클라이언트는 서버 인터페이스에만 의존하고, DI를 통해 서버, 프록시를 대체할 수 있다.

[프록시의 주요기능]
* 접근제어 : 권한에 따른 접근 차단, 캐싱, 지연로딩 => `프록시 패턴`
* 부가기능추가 : `데코레이터 패턴`

데코레이터 패턴에서 데코레이터들은 항상 __꾸며줄 대상__ 이 필요하다. 따라서 내부에서 호출 대상을 가지고 있어야 한다. 그리고 이 대상을 호출해야 하는데 이 부분이 __중복__ 된 코드로 나타난다. 그래서 중복 제거를 위해 추상클래스를 만드는 방법이 있다.

*인터페이스가 없는 구체 클래스에 프록시를 적용할 때 구체 클래스를 상속받아서 해당 메서드를 오버라이딩하여 부가기능을 추가한다.

## 리플렉션

## 동적 프록시

## 스프링이 지원하는 프록시(프록시 팩토리)

## 빈 후처리기

## AOP

## 스프링 AOP 주의사항