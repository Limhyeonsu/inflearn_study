# 04. 스프링 데이터 JPA

## 1부 핵심 개념 이해
### 9. 1:N 매핑
관계에는 항상 두 엔티티가 존재하고, 둘중 하나는 관계의 주인, 나머지는 종속된 쪽이다.

단방향 관계에서 관계의 주인은 관계를 정의한 쪽이다.
* 단방향 @ManyToOne - 기본값은 `FK` 생성한다.
* 단방향 @OneToMany - 기본값은 `조인 테이블`을 생성한다.
* 양방향 - FK를 가지고 있는쪽이 관계의 주인이다. 주인이 아닌쪽에는 mappedBy를 사용해서 관계의 주인인 필드명을 설정해주어야 한다. 또한 DB에 저장할때 관계의 주인쪽에 관계 매핑을 저장해야 정상적으로 FK가 저장된다. 

예)
```
//study가 관계의 주인, account가 종속
account.getStudies().add(study); //옵션이지만 객체지향적으로 생각했을때 함께 사용하는 것이 좋다.
study.setOwner(account); //필수

//메서드로 만드는 방법도 있음
account.addStudy(study);

class Account {
    //..
    
    public void addStudy(Study study) {
        this.getStudies().add(study);
        study.setOwner(this);
    }
}
```

### 10. Cascade
Cascade는 엔티티의 상태 변화를 전파시키는 옵션이다.

[엔티티 상테]
* Transient : JPA가 모르는 상태
* Persistent : JPA가 관리중인 상태
  * 1차 캐시
  * Dirty Checking : 객체의 변경상태를 계속해서 감지하는 것
  * Write Behind : 객체의 상태 변화를 데이터베이스에 최대한 늦게, 가장 필요한 시점에 적용한다.
* Detached : JPA가 더이상 관리하지 않는 상태
* Removed : JPA가 관리하긴 하지만 삭제하기로 한 상태

Cascade 사용을 하기 위해서는 도메인 관계가 부모-자식 관계가 좋다. account가 사라진다고 해서 study도 사라진다면 부모-자식 관계라고 볼 수 있지만 study는 사라지지 않는다면 부모-자식관계라고 할 수 있다.

### 11. Fetch
연관관계의 엔티티를 가져올때, 
* ~ToMany : 기본값은 Lazy(나중에)
* ~ToOne : 기본값은 Eager(지금)

### 12. Query
* JPQL : DB 테이블이 아닌 엔티티 객체 모델 기반으로 쿼리 작성
* Criteria : 타입 세이프 쿼리
* Native Query : SQL 쿼리 실행

### 13. 스프링 데이터 JPA
interface에 JpaRepository를 extends하면 @Repository를 붙이지 않아도 빈으로 등록해주고, 기본 CRUD 메서드를 제공해줌

빈으로 자동으로 등록해주는 것은 @EnableJpaRepositories 애너테이션을 타고 들어가면 ImportBeanDefinitionRegistrar 인터페이스가 등장하는데 거기서 자동으로 빈을 등록해주고 있다. __@EnableJpaRepositories 애너테이션은 스프링부트에서는 자동으로 해주기 때문에 생략가능__

### 14. 핵심 개념 이해 정리

## 2부 스프링 데이터 JPA 활용
### 15. 스프링 데이터 JPA 활용 파트 소개
* 스프링 데이터
  * 스프링 데이터 Common
    * 스프링 데이터 JPA
  * 스프링 데이터 REST

### 16. 스프링 데이터 Common: Repository
* 스프링 데이터 Common
  * Repository - 별기능이 없는 마크용 인터페이스
  * CrudRepository
  * PagingAndSortingRepository
* 스프링 데이터 JPA
  * JpaRepository

### 17. 스프링데이터 Common: Repository 인터페이스 정의하기
이미 만들어져 있는 Repository 인터페이스를 사용하고 싶지 않은 경우에는(기본적으로 제공하는 메서드를 사용하고 싶지 않은 경우)

Repository 인터페이스 생성후 @RepositoryDefinition 애너테이션을 사용한다.

```java
@RepositoryDefinition(domainClass = Comment.class, idClass = Long.class)
public interface CommentRepository {
    Comment save(Comment comment);
    List<Comment> findAll();
}
```

공통 메서드를 지정하고 싶은 경우 아래와 같이 생성하고 아래의 인터페이스를 상속받으면 된다

```java
@NoRepositoryBean
public interface MyRepository<T, ID extends Serializable> extends Repository<T, ID> {
  <E extends T> E save(E entity);
  List<T> findAll();
}
```

### 18. 스프링데이터 Common: Null 처리하기
스프링 2.0부터 Optional 지원, Optional은 Null을 리턴하지 않고, 비어있는 콜렉션을 리턴한다. 또 Optional에서 제공하는 여러 메서드를 사용할 수 있다.

List 타입도 없으면 빈 List를 리턴하지 Null을 리턴하지 않는다. 따라서 null 체크를 할 필요 없음.

메서드 자체에 리턴값이나, 파라미터에 null 체크를 하고 싶은 경우 @NonNullApi(패키지 레벨에 붙임), @NonNull, @Nullable 을 사용할 수 있다.

인텔리제이에서 스프링에서 지원하는 Nullable을 인식하지 못하는 경우가 있다.

```
설정
  Build, Execution, Deployment
    ○ Compiler
      ■ Add runtime assertion for notnull-annotated methods and parameters
        스프링 애너테이션 추가
```

### 19. 스프링데이터 Common: 쿼리 만들기 개요
메서드 이름으로 쿼리 만드는 방법
1. 메서드 이름을 분석해서 쿼리 생성 (CREATE)
2. @Query를 통해 미리 정의해둔 쿼리를 찾아 사용 (USER_DECLARED_QUERY) 
   * @Query 뿐만 아니라 @PreparedStatement, @NamedQuery 등도 사용할 수 있음
   * 그럴일이 없겠지만 여러개의 애너테이션이 등록된 경우 Query > Procedure > NamedQuery 순으로 적용된다.
3. 1,2를 합친 버전으로 먼저 정의된 쿼리가 있는지 찾아보고 없으면 만듬 (CREATE_IF_NOT_FOUND) -> `기본값`
   * @EnableJpaRepositories 가 선언된 곳에 queryLookupStrategy = QueryLookupStrategy.Key.CREATE_IF_NOT_FOUND)로 설정

### 20. 스프링데이터 Common: 쿼리 만들기 실습

```java
//기본
List<Person> findByEmailAddressAndLastname(EmailAddress emailAddress, String lastname);

//정렬
List<Person> findByLastnameOrderByFirstnameAsc(String lastname);

//페이징
Page<User> findByLastname(String lastname, Pageable pageable);
Slice<User> findByLastname(String lastname, Pageable pageable);
List<User> findByLastname(String lastname, Sort sort);
List<User> findByLastname(String lastname, Pageable pageable);

//스트리밍 try-with-resource 사용해서 스트림 사용 완료후 close() 해주어야 함
Stream<User> readAllByFirstnameNotNull(); 

```

### 21. 스프링데이터 Common: 비동기 쿼리 메서드

```java
//1. non-blocking으로 만들 수 있다.
@Async
Future<User> findByFirstname(String firstname);

Future<User> future = userRepository.findByFirstname(firstname);
future.isDone(); //결과가 나왔는지 확인
User user = future.get(); //결과가 나올때까지 기다림

//2.
@Async
CompletableFuture<User> findOneByFirstname(String firstname);

//3. future에 콜백을 등록해서 작업을 설정할 수 있다.
@Async 
ListenableFuture<User> findOneByLastname(String lastname);
```

__Async로 동작하게 하려면 @EnableAsync를 붙여주어야 함, 테스트 코드 작성하기 어려움__

비동기로 해도 같은 트랜잭션 안에서 동작하는데 먼저 쓰레드가 작업이 끝나게 되면 다른 쓰레드는 원래 쓰레드의 데이터 변화를 감지하지 못한다.

### 22. 스프링데이터 Common: 커스텀 리포지토리

```java
public interface PostCustomRepository<T> {

    List<Post> findMyPost();
    void Delete(T entity);
}

//커스텀 리포지토리를 구현하는 클래스의 명칭은 ~Impl을 붙여주어야 한다.
@Repository
@Transactional
public class PostCustomRepositoryImpl implements PostCustomRepository<Post> {

    @Autowired
    EntityManager entityManager;
    
    @Override
    public List<Post> findMyPost() {
        return entityManager.createQuery("SELECT p FROM Post AS p", Post.class).getResultList();
    }

    @Override
    public void delete(Post entity) {
        return entityManager.remove(entity);
    }
}

//기본 리포지토리에 커스텀 리포지토리도 추가해준다
public interface PostRepository extends JpaRepository<Post, Long>, PostCustomRepository<Post> {}
```

스프링 데이터 리포지토리에서 제공하는 기본 메서드를 덮어 씌우는 것도 가능하다. 메서드 명이 겹치는 경우 Spring Data JPA는 커스텀하게 구현한 구현체를 더 우선시 한다.

커스텀 리포지토리의 접미어를 Impl 대신 다른걸로 바꾸고 싶은 경우 @EnableJpaRepositories(repositoryImplementationPostfix = "접미어로 설정하고 싶은 값")

### 23. 스프링데이터 Common: 기본 리포지토리 커스터마이징
모든 리포지토리에 공통적으로 추가하고 싶은 기능이 있다거나 덮어씌우고 싶은 기본 기능이 있는 경우

```java
//중간에 있는 Repositroy에는 NoRepositoryBean를 선언해주어야 한다
@NoRepositoryBean
public interface MyRepository<T, ID extends Serializable> extends JpaRepository<T, ID> {
    boolean contains(T entity);
}

//MyRepository 구현체 정의
public class SimpleMyRepository<T, ID extends Serializable> extends SimpleJpaRepository<T, ID> implements MyRepository<T, ID> {
    private EntityManager entityManager;
    
    public SimpleMyRepository(JpaEntityInformation<T, ?> entityInformation, EntityManager entityManager) {
        super(entityInformation, entityManager);
    }

    @Override
    public void contains(T entity) {
        return entityManager.contains(entity);
    }
}

public interface PostRepository extends MyRepository<Post, Long>, PostCustomRepository<Post> {}
```
@EnableJpaRepositories(repositoryBaseClass = SimpleMyRepository.class) 설정해주어야 함



















